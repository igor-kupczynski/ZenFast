# ZenFast Technical Design Document

## Overview

This document outlines the technical implementation of ZenFast, a Telegram bot for small groups of trusted users. The design prioritizes simplicity and follows YAGNI (You Aren't Gonna Need It) principles.

**Reference**: Product Requirements Document - `/specs/prd-001.md`

## Architecture

### Platform
- **Runtime**: Cloudflare Workers
- **Storage**: Cloudflare Workers KV
- **Language**: TypeScript
- **External Dependencies**: Telegram Bot API only

### System Components

```
┌─────────────────┐     HTTPS      ┌──────────────────┐
│ Telegram Users  │ ◄────────────► │ Telegram Servers │
└─────────────────┘                └────────┬─────────┘
                                            │ Webhook
                                            ▼
                                    ┌────────────────────┐
                                    │ Cloudflare Worker  │
                                    │   (ZenFast Bot)    │
                                    └────────┬───────────┘
                                             │
                              ┌──────────────┴──────────────┐
                              ▼                             ▼
                      ┌───────────────┐            ┌────────────────┐
                      │ API_KEYS (KV) │            │ CHATS (KV)     │
                      └───────────────┘            └────────────────┘
```

## Storage Design

### KV Namespaces

**1. API_KEYS Namespace**
- Stores API key metadata
- Key format: `sha256:<hash-of-api-key>` (SHA-256 hash of the 5-word phrase)
- Value structure:
```json
{
  "name": "Igor's phone",
  "expiry": "2024-12-31T23:59:59Z",
  "created": "2024-01-01T00:00:00Z"
}
```

**2. CHATS Namespace**
- Stores chat-to-API-key associations after successful authentication
- Key format: `<chat_id>` (Telegram chat ID, e.g., "123456789" for private chats, "-1001234567890" for groups)
- Value structure:
```json
{
  "api_key_hash": "sha256:a1b2c3d4e5f6...",  // SHA-256 hash of the authenticated key
  "authenticated_at": "2024-01-15T10:30:00Z",
  "authenticated_by": {
    "user_id": 987654321,
    "username": "alice",
    "first_name": "Alice"
  }
}
```

**Important Notes**:
- Each chat (private or group) can only have ONE associated API key
- Once authenticated, ALL users in that chat share the same API key privileges
- Re-authentication with a different key overwrites the previous association
- No audit trail of previous keys (simplicity over history)
- Private chats have positive IDs, group chats have negative IDs

### Storage Operations
- No TTL set on any KV entries (permanent storage)
- Expiry checking done in application logic
- All dates stored in ISO 8601 format (UTC)

## API Key Design

### Format
- 5 random words from a 2000-word dictionary
- Format: `word1-word2-word3-word4-word5`
- Example: `correct-horse-battery-staple-zebra`
- ~55 bits of entropy

### Storage Security
- Keys are stored as SHA-256 hashes in KV (not plaintext)
- Original key shown only once during generation
- Cannot recover lost keys (must generate new ones)

### Generation
- CLI tool generates keys and stores them directly in KV
- No API endpoint for key generation (security)
- Requires Cloudflare credentials to run

## Authentication Flow

### First-Time Authentication
```
User: "Hello bot"
Bot: "Please authenticate with your API key."
User: "correct-horse-battery-staple-zebra"
Bot: [Hashes provided key and checks if hash exists in API_KEYS KV]
Bot: [Validates not expired]
Bot: [Stores chat_id → api_key_hash in CHATS KV with user info]
Bot: "Authentication successful! How can I help?"
```

### Subsequent Messages
```
User: "Hello again"
Bot: [Checks CHATS KV for existing auth using chat_id]
Bot: [Retrieves api_key_hash from CHATS entry]
Bot: [Validates key not expired by checking API_KEYS KV]
Bot: "Hello! How can I help?"
```

### Edge Cases
- **Expired key**: "Your API key has expired. Please contact the bot owner for a new key."
- **Invalid key**: "Invalid API key. Please check and try again."
- **Group already authenticated**: "This group is already authenticated."

## Webhook Security

### Implementation
Using Telegram's recommended secret token approach:

1. Generate random secret during bot setup
2. Configure webhook with secret:
```typescript
setWebhook({
  url: "https://zenfast.example.workers.dev/webhook",
  secret_token: "random-secret-token-here"
})
```

3. Validate on every request:
```typescript
if (request.headers.get("X-Telegram-Bot-Api-Secret-Token") !== env.WEBHOOK_SECRET) {
  return new Response("Unauthorized", { status: 401 });
}
```

## Message Processing

### Scope
- **Private chats**: Process all messages after authentication
- **Group chats**: Process all messages after authentication (not just mentions)
- **Channels**: Same as group chats

### Basic Flow
1. Receive webhook from Telegram
2. Validate webhook secret
3. Extract chat_id from message
4. Check authentication status
5. If not authenticated, prompt for API key
6. If authenticated, echo message back (Phase 1 - no commands)

## Environment Configuration

### Cloudflare Worker Environment Variables
```toml
# wrangler.toml
name = "zenfast"

[env.production]
vars = { WEBHOOK_SECRET = "your-secret-here" }

[[kv_namespaces]]
binding = "API_KEYS"
id = "your-kv-namespace-id-1"

[[kv_namespaces]]
binding = "CHATS"
id = "your-kv-namespace-id-2"
```

### Telegram Bot Configuration
- Create bot via @BotFather
- Disable group privacy mode (to see all messages) - Note: This can be changed later via @BotFather if needed
- Set webhook URL after deployment

## Deployment Process

1. **Create KV namespaces**:
```bash
wrangler kv:namespace create "API_KEYS"
wrangler kv:namespace create "CHATS"
```

2. **Generate and store API keys** (single command):
```bash
npm run generate-key -- --name "Igor's phone" --expiry "2024-12-31"
# Output: 
# Generated API key: correct-horse-battery-staple-zebra
# Key stored successfully for 'Igor's phone' (expires: 2024-12-31)
# Save this key securely - it cannot be recovered!
```

3. **Deploy worker**:
```bash
wrangler deploy
```

4. **Set webhook**:
```bash
curl https://api.telegram.org/bot<TOKEN>/setWebhook \
  -d "url=https://zenfast.example.workers.dev/webhook" \
  -d "secret_token=your-secret-here"
```

## Development & Local Testing

### Local Development Setup

1. **Install dependencies**:
```bash
npm install -g wrangler
npm install
```

2. **Environment setup**:
Create `.dev.vars` file (ignored by git):
```
WEBHOOK_SECRET=your-local-webhook-secret
```

3. **Run locally**:
```bash
wrangler dev
# Worker runs at http://localhost:8787
```

### Testing Strategy

1. **Unit tests**: Test authentication logic and message processing
```bash
npm test
```

2. **Local integration testing**:
```bash
# Test webhook with curl (no Telegram needed)
curl -X POST http://localhost:8787/webhook \
  -H "X-Telegram-Bot-Api-Secret-Token: your-local-webhook-secret" \
  -H "Content-Type: application/json" \
  -d '{"message":{"chat":{"id":123},"text":"Hello"}}'
```

3. **Testing with miniflare** (Cloudflare Worker emulator):
```bash
npm run test:miniflare
```

### Development Workflow

1. Make changes to TypeScript code
2. Test locally with `wrangler dev`
3. Run tests with `npm test`
4. Test webhook locally with curl
5. Deploy to production: `wrangler deploy`

### Debugging Tips

- Use `console.log()` for local debugging (logs appear in terminal)
- Use `wrangler tail` to see production logs
- Test different Telegram message types locally:
```bash
# Test authentication
curl -X POST http://localhost:8787/webhook \
  -H "X-Telegram-Bot-Api-Secret-Token: your-local-webhook-secret" \
  -H "Content-Type: application/json" \
  -d '{"message":{"chat":{"id":123},"text":"correct-horse-battery-staple-zebra"}}'

# Test regular message (after auth)
curl -X POST http://localhost:8787/webhook \
  -H "X-Telegram-Bot-Api-Secret-Token: your-local-webhook-secret" \
  -H "Content-Type: application/json" \
  -d '{"message":{"chat":{"id":123},"text":"Hello bot!"}}'
```

## Error Handling

### Approach
- Return user-friendly error messages via Telegram
- No error logging (privacy, simplicity)
- Let Cloudflare handle infrastructure errors
- Respond with 200 OK even on application errors (Telegram best practice)

### Common Errors
- KV unavailable: "Service temporarily unavailable. Please try again."
- Invalid message format: Ignore silently
- Webhook validation failure: Return 401 (blocks request)

## Security Considerations

1. **No sensitive data in logs**: Worker doesn't log messages or API keys
2. **HTTPS only**: Enforced by Cloudflare Workers
3. **API key transmission**: One-time via Telegram's encrypted chat
4. **No key enumeration**: Can't list or discover valid keys
5. **Rate limiting**: Rely on Cloudflare's built-in DDoS protection
6. **Public repository**: Never commit secrets (bot token, webhook secret, API keys) to the repository. Use environment variables and wrangler secrets for all sensitive data

## Performance Targets

- **Response time**: < 500ms for auth check + echo
- **Cold start**: < 50ms (Workers are fast)
- **Concurrent requests**: 50+ (Workers auto-scale)

## Limitations & Simplifications

1. **No command framework**: Just echo messages after auth
2. **No user management**: Owner manually manages keys
3. **No audit logging**: No tracking of who did what
4. **No key rotation helpers**: Users re-auth manually
5. **No backup/restore**: Rely on KV durability
6. **Single region**: Use Cloudflare's default
7. **No monitoring**: Users report issues directly

## Future Considerations

When extending the bot with actual commands:
1. Add command parsing after auth check
2. Store command state in KV if needed
3. Consider Durable Objects for complex state
4. Add structured logging for debugging

## Summary

This design delivers a minimal but functional authenticated Telegram bot that:
- Meets all PRD requirements
- Costs < $5/month (likely free tier)
- Deploys in minutes
- Requires minimal maintenance
- Provides a foundation for future features

The implementation focuses on getting a working bot quickly while maintaining security and reliability for the target use case of friends and family.
